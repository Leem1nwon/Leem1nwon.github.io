---
layout: single
title: "Function"
---

# Function

## 1. 정의

#### 1-1. C++ 프로그램의 함수
- c++ 표준 라이브러리 (함수와 클래스)
- Third-Party 라이브러리 (함수와 클래스)
- 직접 구현한 함수와 클래스

#### 1-2. 함수를 사용하는 이유?
함수 &rarr; 모듈화 &rarr; 재사용성
- 코드를 독립적인 연산으로 분할
- 연산들을 재사용

기존 코드
```cpp
int main()
{
    // read input
    statement1;
    statement2;

    // process input
    statement3;
    statement4;
    statement5;

    // write output
    statement6;
    statement7;

    return 0;
}
```

모듈화

```cpp
int main()
{
    readInput();
    processInput();
    writeOutput();

    return 0;
}
```
#### 1-3. 함수 사용시 유의할 것

**알아야 하는 것은?**
- 함수의 기능
- 함수에서 필요로 하는 정보
- 함수가 리턴하는 것
- 어떤 오류가 발생하는지
- 성능상의 제약

**몰라도 되는 것은?**
- 함수가 내부적으로 어떻게 동작하는지

<cmath> 라이브러리 함수 예시

수학 연산 함수들을 제공.

```cpp
std::cout << sqrt(400.0) << std::endl;
double result;
result = pow(2.0, 3.0);
```
함수가 내부적으로 어떻게 동작하는지 몰라도 사용할 수 있음.

#### 1-4. 함수 정의

함수 정의에는 다음과 같은 요소들이 필요하다.
1. 이름
   - 함수의 이름
   - 변수의 명명 규칙과 동일
   - **의미가 있는 이름이어야 함**
2. 매개변수 리스트
   - 함수에 전달되는 값(인자)들
   - 타입이 명시되어야 함
3. 리턴 타입
   - 연산 결과의 반환 타입
4. 본문
   - 함수가 호출되었을 때 실행되는 명령문
   - 중괄호("{}") 내부

```cpp
returnType FunctionName(parameters) {
    statements;

    return 0;
}
```

---

## 2. 프로토타입

함수의 **호출 이전**에 함수의 정의를 알 수 있어야 함!
&rarr; 매개변수가 몇 개고, 어떤 타입의 데이터를 리턴하는지 알려주어야 함

#### 방법 1: 항상 함수의 호출보다 위쪽 라인에 함수를 정의
- 작은 프로그램에서는 ok
- 일반적으로 효율적인 방법이 아니다.

#### 방법 2: 함수 프로토타입의 사용
- 함수의 전체 정의가 아닌, **컴파일러가 알아야 할 부분만** 미리 알려주는 개념
- 전방 선언(forward declaration) 이라고도 명칭
- 프로그램의 초기에 위치
- 헤더 파일(.h)의 활용

```cpp
void SayHello();                // Functino Prototype

int main() {
    sayHello();                 // ok
    sayHello(100);              // Error
    std::cout << SayHello();    // Error
}
```

---

## 3. 매개변수(parameter)와 pass-by-value ✭

#### 3-1. 함수 매개변수란?
- 함수를 호출할 때, 데이터를 전달할 수 있음
  - 함수의 호출에 있어서 전달하는 값은 인수(argument)라 함
  - 함수의 정의에 있어서 전달하는 값은 인자 또는 매개변수(parameter)라 함
- 인수와 매개변수는 개수, 순서와 타입이 일치해야 함

```cpp
int AddNumbers(int, int)    // Prototype

int main() {
    int result = 0;
    result = AddNumbers(100,200);   // Call(use)
    return 0;
}

int AddNumbers(int first, int second){   // Definition
    return first + second;
}
```

#### 3-2. Pass-by-value

함수에 데이터를 전달할 때는 값으로 전달(pass-by-value)됨
- 데이터의 값이 **복사되어** 전달
  - 함수 내에서는 원본에서 복사해서 만들어진 사본이 사용됨
- 전달된 인수는 함수를 통해 변화되지 않음
  - 사본을 바꾼다고 원본이 바뀌지 않음
  - 실수로 값을 변화하는 것을 방지
  - **원본을 변화시키는 것이 필요하거나, 복사 비용이 높을 때를 위한 방법 존재 (포인터/참조자)**

```cpp
#include <iostream>
using namespace std;

void ParamChange(int formal) {  // formal은 actual의 사본
    cout << formal << endl;     // 50
    formal = 100;
    cout << formal << endl;     // 100
}

int main() {
    int actual = 50;            // 원본. Main()함수 안의 actual이라는 변수
    cout << actual << endl;     // 원본의 값은 50
    ParamChange(acutal);        // actual을 함수에 전달
    cout << actual << endl;     // 50 <-- 원본 값은 변하지 않음음
    return 0;
}
```

---

## 4. return문

**반환(return)**
- return 문을 통해서 함수의 결과값을 전달
  - void형 반환인 경우 return 문 생략 가능
- return문은 함수 내 어느 곳에서나 정의 가능
- return문을 통해 함수는 **즉각적으로 종료**
  
---

## 5. 기본 인수(default argument)

**기본인수**
- (Remind) 함수의 선언에서 정의한 모든 매개변수가 전달되어야 함
- 기본 인수를 사용하면, 인수가 주어지지 않을 시 기본값을 사용하돌고 정의 가능
  - 동일한 값을 자주 사용할 경우 용이함
- 기본값은 함수 프로토타입 또는 정의부에 선언
  - **프로토타입에 선언하는 것이 기본**
  - 둘 다 선언해서는 안됨.
- 여러 개의 기본값을 사용할 경우 오른쪽부터 선언해야 함.

```cpp
include <iostream>

double CalcCost(double baseCost, double taxRate = 0.06, double shipping = 3.5)  // 세율, 배송비는 고정된 경우가 많으므로, 기본 인수를 사용하여 실수 방지지

int main() {
    double cost = 0;
    cost = CalcCost(100.0, 0.08, 4.5);
    cost = CalcCost(100.0, 0.08);
    cost = CalcCost(200.0);
    return 0;
}

double CalcCost(double baseCost, double taxRate, double shipping) {
    return baseCost += (baseCost * taxRate) + shipping;
}
```

---

## 6. 오버로딩 ✭

#### 6-1. 함수 오버로딩이란?
- 서로 다른 매개변수 리스트를 갖는 동일한 이름의 함수를 정의하는 것
- 추상화(Abstraction)의 한 예
- 다형성(Polymorphism)의 한 예
  - 유사한 개념의 함수를 다른 타입에 대해 정의
- 객체지향 프로그램 구현을 위한 중요한 기법 중 하나
- 컴파일러는 주어진 인수와 함수들의 파라미터 정의를 기반으로 개별적인 함수를 구분할 수 있어야 함

#### 6-2. 추상화 (Abstraction)
추상화는 **필요한 부분만 보여주고 불필요한 세부 사항은 숨기는 개념**이다.  
함수 오버로딩을 사용하면 **"어떤 기능을 수행하는 함수"** 라는 의미만 드러내고, 매개변수의 차이에 따른 내부 구현은 숨길 수 있다.

```cpp
#include <iostream>
using namespace std;

void print(int x) {
    cout << "정수: " << x << endl;
}

void print(double x) {
    cout << "실수: " << x << endl;
}

void print(string x) {
    cout << "문자열: " << x << endl;
}

int main() {
    print(10);        // 정수 버전 호출
    print(3.14);      // 실수 버전 호출
    print("Hello");   // 문자열 버전 호출
    return 0;
}
```

- `print()` 함수의 이름은 동일하지만, **매개변수의 타입만 다름**  
- 사용자는 `print()`를 호출할 때 **"출력한다"** 라는 기능만 알면 됨 → **추상화**



#### 6-3. 다형성 (Polymorphism)
다형성은 **동일한 이름의 함수가 서로 다른 동작을 수행할 수 있도록 하는 것**이다.  
함수 오버로딩을 사용하면 같은 함수 이름이지만, 전달되는 **매개변수의 타입이나 개수에 따라 다른 동작을 수행**할 수 있다.

```cpp
#include <iostream>
using namespace std;

class Calculator {
public:
    int add(int a, int b) {
        return a + b;
    }

    double add(double a, double b) {
        return a + b;
    }
};

int main() {
    Calculator calc;
    cout << calc.add(5, 10) << endl;    // 정수 덧셈 (5 + 10)
    cout << calc.add(2.5, 3.5) << endl; // 실수 덧셈 (2.5 + 3.5)
    return 0;
}
```

- `add()` 함수가 **정수와 실수를 구별해서 다르게 동작**  
- 같은 이름이지만 입력값에 따라 다른 결과 → **다형성**  

#### 6-3. 정리

- **추상화**: 사용자는 `print()` 또는 `add()` 함수가 "출력" 또는 "덧셈"을 한다는 것만 알면 되고, **내부적으로 어떤 버전이 실행되는지는 신경 쓰지 않아도 됨**  
- **다형성**: 같은 `print()` 또는 `add()` 함수가 **입력값의 타입에 따라 다르게 동작할 수 있음**  

결론적으로 **함수 오버로딩은 "추상화"와 "다형성"을 동시에 실현하는 중요한 개념**이다!

---

## 7. 함수 호출의 동작 방식 ✭

#### 7-1. Local/Global Scope

**지역 범위**
- 블록 {} 내의 범위
- **함수의 매개변수까지 함수 범위 내의 지역 변수로 생각해야 함**
  - for 문에서 int i = 0 이 블록 내 범위인 것과 마찬가지
- 따라서 함수의 (복사된) 인자 및 지역 변수들은 함수의 실행 중에만 존재함

**static 지역 변수**
- static 한정어를 사용해 지역 내에 정의된 변수를 지역 밖에 정의한 것처럼 활용 가능
- 단, scope 밖에서 접근할 수는 없음음
- 초기화가 필요

```cpp
void StaticLocalIncrement() {
    static int num = 1;
    std::cout << "num : " << num << std::endl;
    num ++;
    std::cout << "num : " << num << std::endl;
}

int main() {
    StaticLocalIncrement()  // 1 2
    StaticLocalIncrement()  // 2 3
    StaticLocalIncrement()  // 3 4
}
```

**전역 범위**
- 함수 밖에 정의된 변수는 어디서나 접근 가능
- 전역 변수는 사용하지 않는 것이 좋음
  - 전역 상수는 ok

#### 7-2. 함수 호출

![memory](../images/2025-02-06-Function/memory_layout.png)

**함수 호출의 동작방식**
- Function call stack
- LIFO(Last in first out)
- Stack Frame (Activation Record)
  - 함수의 호출이 발생할 때마다, 일종의 구분선이 정의됨
  - 함수의 지역 변수와 매개 변수는 그 구분선 영역 내에 생성됨
  - 함수의 호출이 끝나면 구분선 내의 메모리는 자동으로 해제됨
- 스택은 유한하고 작아서, stack overflow 발생할 수 있음

연습 코드

```cpp
int Func2(int x, int y, int z)
{
    x += y + z;
    return x;
}

int Func1(int a, int b)
{
    int result;
    result = a + b;
    result = Func2(result, a, b);
    return result;
}

int main()
{
    int x = 10;
    int y = 20;
    int z;
    z = Func1(x, y);
    cout << z << endl;
    return 0;
}
```

---

## 8. 포인터와 참조자 ✭

#### 8-1. 범위 밖 메모리의 조작
- Func2()를 실행 중일 때, main() 및 Func1()의 지역 변수들에 대한 접근은 불가능한 것일까?
- 가능하다. 다만 이런 접근이 가능하려면 다른 타입의 변수를 사용해야 함.
    1. 포인터 : 메모리 주소값을 갖는 변수
    2. 참조자 : 변수에 또다른 이름(별명)을 부여

#### 8-2. Pass-by-address (Reference)
- 포인터를 함수로 전달하는 예시
  - 주소값을 명시하는 포인터를 활용하여 범위 밖 메모리에 접근할 수 있음

```cpp
void ChangeValue(int* number);

int main() {
    int number = 10;
    std::cout << number << std::endl;   // 10
    ChangeValue(&number);
    std::cout << number << std::enld;   // 20
}

void ChangeValue(int* ptr) {  // ptr는 int를 가리키는 포인터 변수
    *ptr = 20;                // 포인터 변수를 역참조하여 값을 변경
}
```
**참조자로 전달**
- 함수 내에서 범위 밖 변수값을 바구고 싶은 경우 사용하는 또다른 방법
  - 값의 변환을 위해서는 매개변수의 주소값(포인터)가 필요
- 배열이 아닌 경우에도 C++에서는 참조자(reference)를 통해 가능
  - C언어를 사용한다면 포인터를 사용할 수밖에 없음
  - C++ 에서는 포인터 또는 참조자 두 가지 옵션이 존재
- 형식 매개변수를 실제 매개변수의 별명처럼 사용하는 개념

```cpp
#include <iostream>
using namespace std;

void Swap(int &a, int &b);

int main()
{
    int x = 10, y = 20;
    cout << x << " " << y << endl; // 10 20
    Swap(x, y);
    cout << x << " " << y << endl; // 20 10
    return 0;
}

void Swap(int &a, int &b)
{
    int temp = a;
    a = b;
    b = temp;
}
```

#### 8-3. 참조자와 메모리

- 참조자를 사용하지 않는 경우에는 **메모리를 두 배 사용!**
- 참조자를 사용하되, 값의 변경이 필요 없을 시에는 const로 안정성 확보

---

## 9. inline 함수

- 함수의 호출에는 오버헤드가 존재
  - Activation stack 생성, 파라메터 처리, pop stack, 리턴값 처리
- 함수를 inline으로 정의하면, 컴파일 단계에서 함수 내의 명령문으로 함수 호출이 대체
  - 일반적인 함수 호출보다 빠르다
  - 단, 바이너리 파일의 용량이 커질 수 있다 (코드 줄이 추가됨)
  - 내가 명시하지 않아도, 컴파일러에서 최적화를 위해 내부적으로 알아서 처리하기도 함

```cpp
#include <iostream>

inline void printHello() {
    std::cout << "Hello, World!" << std::endl;
}

int main() {
    printHello();  // 함수 호출이 아니라, 이 자리에 코드가 그대로 삽입됨
    return 0;
}
```

---

## 10. 재귀 함수(recursive)

- 스스로를 호출하는 함수
- Factorial
  - 재귀 호출을 끝내는 base case가 반드시 실행되어야 함 (stack overflow 주의!)

```cpp
unsigned long long Factorial(unsigned long long n) {
    if(n=0) { // Base case
        return 1;
    }
    return n * Factorial(n-1)
}

int main() {
    std::cout << Factorial(5) << std::endl;
    return 0;
}
```
---

## 11. 정리
- **정의** (모듈화, 이름 + 매개변수 + 본문 + 리턴)
- **프로토타입** (호출 전에 컴파일러가 함수의 인자와 반환형을 알 수 있도록)
- **매개변수(parameter)와 pass-by-value** (**인자는 복사하여 전달된다**)
- **Return문**
- **기본 인자(default argument)** (기본값, 오른쪽부터 선언해준다)
- **오버로딩** (동일 이름, 유사 동작, 다른 타입)
- **함수 호출 동작방식**  
  1. 함수 호출하면? ➝ **구분선이 생김**
  2. 구분선 안에는? ➝ **지역변수 공간(매개변수 포함)**
  3. 함수가 끝나면? ➝ **자동으로 사라짐**
- **포인터와 참조자** (원래는 접근할 수 없는 다른 메모리 영역의 변수를 변환하고 싶을 때 사용)
- **inline 함수**
- **재귀 함수(recursive)**

---

### 참고 자료
이 문서 작성에는 [YouTube Playlist: C++ Programming][playlist]를 참고했습니다.

[playlist]: https://www.youtube.com/playlist?list=PLMcUoebWMS1nzhlx-NbD4KBGEP1UCUDF_
