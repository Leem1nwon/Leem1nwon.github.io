---
layout: single
title: "Pointer"
---

# 포인터

## 1. 포인터 개요

#### 1-1. 메모리에 대한 이해
![memory_layout](../images/2025-02-06-Function/memory_layout.png)

**Stack 메모리의 특징**
- very fast access
- don't have to explicitly de-allocate variables
- space is managed efficiently by CPU, memory will not become fragmented
- local variables only
- limit on stack size
- variables cannot be resized

**Heap 메모리의 특징**
- variables can be accessed globally
- no limit on memory size
- (relatively) slower access
- no guaranteed efficient use of space, memory may become fragmented over time as blocks of memory are allocated, then freed
- you must manage memory (you're in charge of allocating and freeing variables)
- variables can be resized using realloc()

#### 1-2. 포인터와 참조자의 차이
- '*' 의 사용
  - 변수를 정의할 때 붙는다? &rarr; 포인터의 정의(포인터 변수의 생성)
  - 변수를 사용할 때 붙는다? &rarr; 포인터의 역참조
- '&' 의 사용
  - 변수를 정의할 때 붙는다? &rarr; 참조자의 정의(참조자의 생성)
  - 변수를 사용할 때 붙는다? &rarr; 변수의 주소값 반환

```cpp
int* a  // 포인터 변수 생성
*a      // 포인터 역참조

int& b  // 참조자의 정의(참조자의 생성)
&a      // 변수의 주소값 반환
```

#### 1-3. 포인터가 그래서 뭔데?

**포인터 변수는 변수의 타입 중 하나**
- 변수의 타입 : int, float, double, int*, float*, ...
  - int와 int*는 다른 타입
- 포인터 타입 변수가 가질 수 있는 값은 **메모리의 주소(memory address)**
  -  지금까지 사용한 변수와 포인터 변수의 차이 : 값을 저장하는지, 주소를 저장하는지
- 포인터는 가리키는 주소에 저장된 데이터의 타입을 알아야 함

**포인터를 사용하는 이유?**
- **동적 할당을 통해 힙 영역의 메모리를 사용**
- **변수의 범위 문제로 접근할 수 없는 곳의 데이터를 사용(참조자와 유사한 목적)**
- 배열의 효율적인 사용
- 다형성은 포인터를 기반으로 구현됨
- 시스템 응용 프로그램 / 임베디드 프로그래밍에서는 메모리에 직접 접근이 필요함

---
## 2. 포인터의 정의

#### 2-1. 정의 방법
기존 변수 타입 뒤에 '*'를 붙여 포인터 변수 정의

```cpp
variableType* pointername
```
#### 2-2. 포인터의 초기화

```cpp
int* intPtr = nullptr;
double* doublePtr = nullptr;
```
- 초기화를 하지 않으면 쓰레기 값이 들어있는 상태이므로 방지가 필요
- nullptr은 'nowhere' 개념
  - 임의의 메모리 주소를 가리키고 있는 상태가 아니라, 아무것도 가리키지 않는 상태를 의미
  
---

## 3. 주소로의 접근

#### 3-.1 변수의 주소값 얻어오기
- 포인터 변수는 주소값을 저장하므로, 주소값을 얻어올 수 있어야 함
- **이를 위해 주소 연산자(&)를 사용**
  - 연산자가 적용되는 피연산자의 주소값이 반환됨, 즉 변수의 주소값이 반환됨
  - 피연산자는 주소값을 얻을 수 있는 종류여야 함(l-value)

```cpp
#include <iostream>
using namespace std;

int num = 10;

cout << "Value : " << num << endl;      // 10
cout << "Address : " << &num << endl;    // 0x1000;    
cout << "Address : " << &10 << endl;    // Error!
```
위의 코드에서는 변수 이름 앞에 &를 붙여서, 그 변수가 저장된 메모리의 주소를 얻을 수 있다.

```cpp
#include <iostream>
using namespace std;

int *p;

cout << "Value : " << p << endl;            // 쓰레기값
cout << "Address : " << &p << endl;         // 쓰레기값
cout << "Address : " << sizeof(p) << endl;  // 4 for address

p = nullptr;

cout << "Value : " << p << endl;            // 0 (초기화됨)
```

#### 3-2. 주소값의 이해
- '포인터 변수의 크기'와 '포인터가 가리키고 있는 대상의 크기' 는 별개이다.
- 포인터 변수들은 모두 같은 크기
  - x86(32bit) 환경에선 4바이트
  - 포인터는 '주소값을' 저장하기 때문

#### 3-3 포인터의 타입
- 그렇다면 타입은 왜 필요할까?
  - 해당 주소의 값에 접근할 때, 그 값이 어떤 타입인지 알아야 함.
  - int는 4바이트를 차지하고, float는 8바이트를 차지함. 어떤 타입의 값이 있느냐에 따라서 어느 범위까지 읽어야 하는지가 달라진다.

아래와 같은 예시에서, 주소에 저장된 변수의 메모리 크기는 모두 다르지만 포인터 변수가 저장하는 주소값은 모두 4바이트 크기로 동일하다.
```cpp
int* p1 = nullptr;
double* p2 = nullptr;
unsigned long long* p3 = nullptr;
vector<string>* p4 = nullptr;
string* p5 = nullptr;
```
- 컴파일러는 포인터가 가리키는 타입이 맞는지 확인한다.
  - ' int* '는 int가 저장된 주소만, ' double* '은 double이 저장된 주소만 가리킬 수 있음

```cpp
int score = 100;
double preciseScore = 100.7;

int* scorePtr = nullptr;    // scorePtr은 int 타입 값이 저장된 메모리 주소만 가질 수 있음.
scorePtr = &score;
scorePtr = &preciseScore    // COMPILER ERROR
```
---

## 4. 역참조

- 포인터의 주소에 저장된 데이터에 접근
- ' * ' 연산자를 사용

```cpp
#include <iostream>
using namespace std;

int score = 10;
int* scorePtr = &score;     // 포인터 변수 정의

cout << *scorePtr << endl;  // 10

*scorePtr = 20;             // 포인터 변수를 역참조하여, 포인터 변수가 가리키는 주소에 접근
cout << *scorePtr << endl;  // 20
cout << score << endl;      // 20
```

---

## 5. 동적 메모리 할당

#### 5-1. 힙 메모리를 할당
- 프로그램의 실행 도중 얼마나 많은 메모리가 필요한지 미리 알 수 없는 경우 사용
  - 사용자 입력에 따라 크기가 바귀는 경우
  - 파일을 선택하여 내용을 읽어오는 경우
- 큰 데이터를 저장해야 할 경우(stack은 크기가 작음, 몇 MB 정도)
- 객체의 생애주기(언제 메모리가 할당되고 해제되어야 할지)를 직접 제어해야 할 경우

- **힙 메모리는 스택과 달리 스스로 해제되지 않음!**
- **사용이 끝나고 해제하지 않으면 메모리 누수 발생!**

#### 5-2. 동적 메모리 할당 방법
- new 연산자 사용
- **new는 heap 메모리 공간에 int 하나를 담을 수 있는 메모리 공간을 할당받은 뒤 그 주소값을 리턴한다.**
```cpp
#include <iostream>
using namespace std;

int* intPtr = nullptr;

intPtr = new int;           // allocate integer in heap
cout << intPtr << endl;     // heap 메모리의 주소
cout << *intPtr << endl;    // garbage value

*intPtr = 100;

cout << *intPtr << endl;    // 100
```

![동적할당](../images/2025-02-08-Pointer/동적할당.png){width=400px}

#### 5-3. 모든 명령문이 끝난 후 메모리의 상태

![동적할당2](../images/2025-02-08-Pointer/동적할당_2.png)

#### 5-4. 동적 메모리의 해제
- delete 연산자 사용
- 해당 메모리 공간의 데이터를 삭제하고 반납
  
```cpp
#include <iostream>
using namespace std;

int* intPtr = nullptr;

intPtr = new int;           // allocate integer in heap
cout << intPtr << endl;     // heap 메모리의 주소
cout << *intPtr << endl;    // garbage value

*intPtr = 100;

cout << *intPtr << endl;    // 100

delete intPtr;              // free
intPtr = nullptr;           // optional
```

---

## 6. 포인터와 배열

- 배열의 이름은 배열의 첫 요소의 주솔를 가리킨다
- 포인터 변수의 값은 주소값이다
- 포인터 변수와 배열이 같은 주소를 가리킨다면, 포인터 변수와 배열은 (거의) 동일하게 사용 가능하다.

```cpp
#include <iostream>
using namespace std;

int scores[] = {100, 95, 90};
cout << scores << endl;         // 00F3FAF8
cout << *scores << endl;        // 100

int* scorePtr = scores;
cout << scorePtr << endl;         // 00F3FAF8
cout << *scores << endl;        // 100
```

```cpp
#include <iostream>
using namespace std;

int main() {
    int scores[] = {100, 95, 90};
    int* scoresPtr = scores;

    cout << scoresPtr << endl;          // 009EF738
    cout << (scoresPtr + 1) << endl;    // 009EF73C
    cout << (scoresPtr + 2) << endl;    // 009EF740

    cout << *scoresPtr << endl;         // 100
    cout << *(scoresPtr + 1) << endl;   // 95
    cout << *(scoresPtr + 2) << endl;   // 90

    return 0;
}
```

---

## 7. 포인터와 const
#### 7-1. const의 포인터(pointers to const)
- 데이터가 const / 포인터는 다른 데이터를 가리킬 수 있음

```cpp
int highScore = 100;
int lowScore = 60;
const int* scorePtr = &highScore;

*scorePtr = 80;       // ERROR, const 데이터를 바꿀 수 없음
scorePtr = &lowScore; // OK
```

#### 7-2. const인 포인터(const pointers)
- 포인터가 const / 데이터는 변할 수 있음
```cpp
int highScore = 100;
int lowScore = 60;
int* const scorePtr = &highScore;

*scorePtr = 80;         // OK
scorePtr = &lowScore;   // ERROR
```

#### 7-3. const의 const인 포인터(const pointers to const)
- 둘 다 const
```cpp
int highScore = 100;
int lowScore = 60;
const int* const scorePtr = &highScore;

*scorePtr = 80;       // ERROR
scorePtr = &lowScore  // ERROR  
```  

---

## 8. 포인터의 pass-by-reference
#### 8-1. 포인터를 함수의 인자로 전달
- pass-by-address / 변수의 주소를 전달

![pass_by_add1](../images/2025-02-08-Pointer/pass_by_address_1.png)
![pass_by_add2](../images/2025-02-08-Pointer/pass_by_address_2.png)

#### 8-2. 포인터의 반환
- 인자로 전달된 데이터(포인터)를 반환하는 경우 &rarr; OK
```cpp
int* LargerInt(int* intPtr1, int*Ptr2) {
  if(*intPtr > *intPtr2)
    return intPtr1;
  else
    return intPtr2;
}
```

- 함수 내부에서 동적으로 할당된 메모리의 주소를 반환 &rarr; OK
```cpp
int* CreateArray(int size, int initValue = 0) {
  int* newStorage = nullptr;
  newStorage = new int[size];
  for (int i = 0; i < size; ++i)
    *(newStorage + i) = initValue;
  return newStorage;
}

int main() {
  int* myArray = nullptr;

  myArray = CreateArray(100, 10);
  delete[] myArray;
  return 0;
}
```
- 단, **지역 변수에 대한 포인터 반환 &rarr; 불가!**

```cpp
#include <iostream>
using namespace std;

int* DontDoThis()
{
	int num = 10;
	int* numPtr = &num;

	return numPtr; // 위험한 코드! 함수가 끝나면 num은 사라짐
}

int main()
{
	int* a = nullptr;
	a = DontDoThis();   // 포인터 변수 a가 가리키는 주소에는 num 이 아닌 쓰레기값이 있음
	cout << *a << endl; // garbage 

	return 0;
}
```

---


## 9. 포인터 주의사항

#### 9-1. 초기화의 필요성
- 포인터는 선언 후 반드시 초기화해야 함.
- 초기화되지 않은 포인터를 사용하면 예측 불가능한 동작(UB, Undefined Behavior)이 발생할 수 있음.

```cpp
int* intPtr;  // anywhere

*intPtr = 100;  // in VS, compiler protects (VS에서는 보호 가능)
```

#### 9-2. 허상 포인터(Dangling Pointer)
- 두 개의 포인터가 같은 메모리를 가리키다가, 하나의 포인터가 메모리를 해제할 경우 발생.
- 지역 변수를 가리키는 포인터를 함수가 반환한 후, 해당 스택 메모리가 해제되는 경우 발생.
```cpp
int* getPointer() {
    int num = 10;  // 지역 변수 (함수 종료 후 사라짐)
    return &num;   // ⚠ 허상 포인터 발생 가능
}

int main() {
    int* ptr = getPointer();
    cout << *ptr << endl;  // ⚠ UB (예측 불가능한 동작)
    return 0;
}
```

#### 9-3. new 연산자의 실패
- new를 사용하여 동적 할당 시, 메모리 할당이 실패할 수도 있음.

#### 9-4. 메모리 누수(Memory Leak)
- 동적 할당된 메모리는 **반드시 해제**해야 함.
- 해제하지 않으면 **메모리 누수가 발생**하여 프로그램이 점점 더 많은 메모리를 차지하게 됨

---
### 참고 자료
이 문서 작성에는 [YouTube Playlist: C++ Programming][playlist]를 참고했습니다.

[playlist]: https://www.youtube.com/playlist?list=PLMcUoebWMS1nzhlx-NbD4KBGEP1UCUDF_
