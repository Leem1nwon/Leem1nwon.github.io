---
layout: single
title: "Pointer"
---

# 포인터

## 1. 포인터 개요

#### 1-1. 메모리에 대한 이해
![memory_layout](../images/2025-02-06-Function/memory_layout.png){width=500px}

**Stack 메모리의 특징**
- very fast access
- don't have to explicitly de-allocate variables
- space is managed efficiently by CPU, memory will not become fragmented
- local variables only
- limit on stack size
- variables cannot be resized

**Heap 메모리의 특징**
- variables can be accessed globally
- no limit on memory size
- (relatively) slower access
- no guaranteed efficient use of space, memory may become fragmented over time as blocks of memory are allocated, then freed
- you must manage memory (you're in charge of allocating and freeing variables)
- variables can be resized using realloc()

#### 1-2. 포인터와 참조자의 차이
- '*' 의 사용
  - 변수를 정의할 때 붙는다? &rarr; 포인터의 정의(포인터 변수의 생성)
  - 변수를 사용할 때 붙는다? &rarr; 포인터의 역참조
- '&' 의 사용
  - 변수를 정의할 때 붙는다? &rarr; 참조자의 정의(참조자의 생성)
  - 변수를 사용할 때 붙는다? &rarr; 변수의 주소값 반환

```cpp
int* a  // 포인터 변수 생성
*a      // 포인터 역참조

int& b  // 참조자의 정의(참조자의 생성)
&a      // 변수의 주소값 반환
```

#### 1-3. 포인터가 그래서 뭔데?

**포인터 변수는 변수의 타입 중 하나**
- 변수의 타입 : int, float, double, int*, float*, ...
  - int와 int*는 다른 타입
- 포인터 타입 변수가 가질 수 있는 값은 **메모리의 주소(memory address)**
  -  지금까지 사용한 변수와 포인터 변수의 차이 : 값을 저장하는지, 주소를 저장하는지
- 포인터는 가리키는 주소에 저장된 데이터의 타입을 알아야 함

**포인터를 사용하는 이유?**
- **동적 할당을 통해 힙 영역의 메모리를 사용**
- **변수의 범위 문제로 접근할 수 없는 곳의 데이터를 사용(참조자와 유사한 목적)**
- 배열의 효율적인 사용
- 다형성은 포인터를 기반으로 구현됨
- 시스템 응용 프로그램 / 임베디드 프로그래밍에서는 메모리에 직접 접근이 필요함

---
## 2. 포인터의 정의

#### 2-1. 정의 방법
기존 변수 타입 뒤에 '*'를 붙여 포인터 변수 정의

```cpp
variableType* pointername
```
#### 2-2. 포인터의 초기화

```cpp
int* intPtr = nullptr;
double* doublePtr = nullptr;
```
- 초기화를 하지 않으면 쓰레기 값이 들어있는 상태이므로 방지가 필요
- nullptr은 'nowhere' 개념
  - 임의의 메모리 주소를 가리키고 있는 상태가 아니라, 아무것도 가리키지 않는 상태를 의미
---

## 3. 주소로의 접근

#### 3-.1 변수의 주소값 얻어오기
- 포인터 변수는 주소값을 저장하므로, 주소값을 얻어올 수 있어야 함
- **이를 위해 주소 연산자(&)를 사용**
  - 연산자가 적용되는 피연산자의 주소값이 반환됨, 즉 변수의 주소값이 반환됨
  - 피연산자는 주소값을 얻을 수 있는 종류여야 함(l-value)

```cpp
#include <iostream>
using namespace std;

int num = 10;

cout << "Value : " << num << endl;      // 10
cout << "Address : " << &num << endl;    // 0x1000;    
cout << "Address : " << &10 << endl;    // Error!
```
위의 코드에서는 변수 이름 앞에 &를 붙여서, 그 변수가 저장된 메모리의 주소를 얻을 수 있다.

```cpp
#include <iostream>
using namespace std;

int *p;

cout << "Value : " << p << endl;            // 쓰레기값
cout << "Address : " << &p << endl;         // 쓰레기값
cout << "Address : " << sizeof(p) << endl;  // 4 for address

p = nullptr;

cout << "Value : " << p << endl;            // 0 (초기화됨)
```

#### 3-2. 주소값의 이해
- '포인터 변수의 크기'와 '포인터가 가리키고 있는 대상의 크기' 는 별개이다.
- 포인터 변수들은 모두 같은 크기
  - x86(32bit) 환경에선 4바이트
  - 포인터는 '주소값을' 저장하기 때문

#### 3-3 포인터의 타입
- 그렇다면 타입은 왜 필요할까?
  - 해당 주소의 값에 접근할 때, 그 값이 어떤 타입인지 알아야 함.
  - int는 4바이트를 차지하고, float는 8바이트를 차지함. 어떤 타입의 값이 있느냐에 따라서 어느 범위까지 읽어야 하는지가 달라진다.

아래와 같은 예시에서, 주소에 저장된 변수의 메모리 크기는 모두 다르지만 포인터 변수가 저장하는 주소값은 모두 4바이트 크기로 동일하다.
```cpp
int* p1 = nullptr;
double* p2 = nullptr;
unsigned long long* p3 = nullptr;
vector<string>* p4 = nullptr;
string* p5 = nullptr;
```
- 컴파일러는 포인터가 가리키는 타입이 맞는지 확인한다.
  - ' int* '는 int가 저장된 주소만, ' double* '은 double이 저장된 주소만 가리킬 수 있음

```cpp
int score = 100;
double preciseScore = 100.7;

int* scorePtr = nullptr;    // scorePtr은 int 타입 값이 저장된 메모리 주소만 가질 수 있음.
scorePtr = &score;
scorePtr = &preciseScore    // COMPILER ERROR
```
---

## 4. 역참조

- 포인터의 주소에 저장된 데이터에 접근
- ' * ' 연산자를 사용

```cpp
#include <iostream>
using namespace std;

int score = 10;
int* scorePtr = &score;     // 포인터 변수 정의

cout << *scorePtr << endl;  // 10

*scorePtr = 20;             // 포인터 변수를 역참조하여, 포인터 변수가 가리키는 주소에 접근
cout << *scorePtr << endl;  // 20
cout << score << endl;      // 20
```

---

## 5. 동적 메모리 할당

#### 5-1. 힙 메모리를 할당
- 프로그램의 실행 도중 얼마나 많은 메모리가 필요한지 미리 알 수 없는 경우 사용
  - 사용자 입력에 따라 크기가 바귀는 경우
  - 파일을 선택하여 내용을 읽어오는 경우
- 큰 데이터를 저장해야 할 경우(stack은 크기가 작음, 몇 MB 정도)
- 객체의 생애주기(언제 메모리가 할당되고 해제되어야 할지)를 직접 제어해야 할 경우

- **힙 메모리는 스택과 달리 스스로 해제되지 않음!**
- **사용이 끝나고 해제하지 않으면 메모리 누수 발생!**

#### 5-2. 동적 메모리 할당 방법
- new 연산자 사용
- new는 heap 메모리 공간에 int 하나를 담을 수 있는 메모리 공간을 할당받은 뒤 그 주소값을 리턴한다. 

```cpp
#include <iostream>
using namespace std;

int* intPtr = nullptr;

intPtr = new int;           // allocate integer in heap
cout << intPtr << endl;     // heap 메모리의 주소
cout << *intPtr << endl;    // garbage value

*intPtr = 100;

cout << *intPtr << endl;    // 100
```

![동적할당](../images/2025-02-08-Pointer%20and%20Reference/동적할당.png){width=400px}

#### 5-3. 모든 명령문이 끝난 후 메모리의 상태

![동적할당2](../images/2025-02-08-Pointer%20and%20Reference/동적할당_2.png)

#### 5-4. 동적 메모리의 해제
- delete 연산자 사용
- 해당 메모리 공간의 데이터를 삭제하고 반납
  
```cpp
#include <iostream>
using namespace std;

int* intPtr = nullptr;

intPtr = new int;           // allocate integer in heap
cout << intPtr << endl;     // heap 메모리의 주소
cout << *intPtr << endl;    // garbage value

*intPtr = 100;

cout << *intPtr << endl;    // 100

delete intPtr;              // free
intPtr = nullptr;           // optional
```

---

## 6. 포인터와 배열
---

## 7. 포인터와 const
---

## 8. 포인터의 pass-by-reference
---

## 9. 주의사항
---
