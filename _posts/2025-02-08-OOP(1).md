---
layout: single
title: "OOP(1)"
---

# Object Oriented Programming (1)

---

## 1. OOP 개요

#### 7-1. 절차적 프로그래밍이란
- 프로그램이 수행하는 일련의 작업을 기준으로 하는 프로그래밍 패러다임
- 작업의 구현 = 함수 / 함수의 집합 = 프로그램
- **데이터와 작업이 분리되어 있는 개념**
- 데이터는 작업의 실행을 위해 매개변수로 전달됨
- 이해하기 쉬운 방식

#### 7-2. 절차적 프로그래밍의 단점
- 함수가 데이터의 구조를 정확히 알아야 함
  - 데이터가 변하면, 함수의 수정이 필요
  - Tightly coupled
- 프로그램 규모가 커지면,
  - 이해하기 어렵고
  - 유지/보수하기 어렵고
  - 확장하기 어렵고
  - 디버깅하기 어렵고
  - 코드를 재사용하기 어렵고
  - 오동작할 확률이 커짐

#### 7-3. 객체지향 프로그래밍의 개념과 장점

**개념**
- 절차적 프로그래밍의 단점을 극복하기 위해 제안된 프로그래밍 패러다임 중 하나
- C++에서는 이러한 방식을 손쉽게 구현할 수 있는 언어 문법을 제공
  - 함수형 프로그래밍 등 새로운 패러다임을 적용할 수 있도록 언어는 계속 확장될 수 있음
- 클래스와 객체를 기반으로 함
  - 데이터와 작업을 하나로 묶어서 표현

**특징**
1. 캡슐화  
   - 클래스는 데이터와 데이터를 기반으로 한 기능을 모두 포함
2. 정보 은닉(추상화)  
   - 사용자는 내부 구현을 알 필요 없이 외부 인터페이스만 사용  
   - 잘못된 사용 및 수정을 방지  
   - 테스트, 디버깅, 유지보수, 확장이 용이해짐
3. 상속
4. 다형성

#### 7-4. 객체지향 프로그래밍의 단점
- 절차적 프로그래밍의 상위 개념은 아님  
  - 때로는 잘 설계된 절차적 프로그램이 더 나을 수 있음  
  - 모든 문제에 어울리는 설계 방안이 아님  
  - 모든 대상이 클래스로 치환되는 것은 아님
- 객체지향 프로그래밍은 어렵다  
  - 직관적이지 않음…
- 문제를 잘 분석하여 좋은 설계를 만들어야 함 (어려움)
- 성능 면에서 손해가 있거나, 지나치게 복잡한 코드가 작성될 수 있음

---
## 2. 클래스와 객체

#### 2-1. 클래스란?
- 플레이어와 여러 명의 적이 존재하는 게임을 만든다고 하자.

절차 지향의 경우, 플레이어 관련 변수와 적 관련 변수들을 만들고, 이러한 변수들을 함수를 사용해 변경하는 방식으로 프로그램 작성
```cpp
int main()
{
    int playerPositionX, playerPositionY;
    int playerSpeed;

    int enemyPositionX, enemyPositionY;
    int enemySpeed;

    ...

    Move(playerPositionX, playerPositionY);
    Move(enemyPositionX, enemyPositionY);
}
```
객체 지향의 경우, 플레이어와 관련된 데이터와 동작을 하나로 묶어 정의하고(클래스) 그로부터 객체를 만들어 사용  
→ 클래스는 붕어빵 틀, 객체는 팥붕, 슈붕 등등...

```cpp
class Player
{
public:
    int x, y;
    int speed;

    void Move(int dx, int dy)
    {
        x += dx * speed;
        y += dy * speed;
    }
};

int main()
{
    Player player1;
    player1.x = 10; player1.y = 10; player1.speed = 2;
    player1.Move(2, 3);

    return 0;
}
```
- 클래스는 객체(object)가 생성되기 위한 틀  
  - 객체가 가져야 할 데이터와 기능을 정의함
- 사용자 정의 '자료형'(user-defined data-type)
- **멤버 변수를 가짐 (데이터)**  
  - 속성(property, attribute), 필드(field), 클래스 변수(class variable) → 멤버 변수
- **멤버 함수를 가짐 (함수, 동작)**  
  - Method → 멤버 함수의 또 다른 용어
- 데이터와 함수를 은닉할 수 있고, 인터페이스를 공개할 수 있음

#### 2-2. 객체란?
- 클래스로부터 생성된 실체  
  - (메모리에 올라간 객체는 인스턴스로 구분하여 명명하기도 함)
- 객체는 개별적으로 관리되며, 원하는 만큼 생성 가능함  
- **객체를 통해** 클래스에 정의된 멤버 함수 호출 및 멤버 변수 접근이 가능함

#### 2-3. 클래스의 선언과 객체의 생성

- 클래스 이름은 자료형(예: int)처럼 사용됨
- **클래스를 정의하는 것 = 새로운 데이터 타입을 만드는 것!**  
  - **실제로 사용할 객체를 생성하여 메모리에 올려야 함**

```cpp
// 변수 타입, 띄고 변수 이름
int highScore;
int lowScore;

// 클래스 타입, 띄고 객체 이름
Player Kim;
Player Lee;
```
**클래스의 정의**
```cpp
class ClassName {
    // declarations
};
```
```cpp
class Player {
    // member variable
    std::string name;
    int health;
    int xp;

    // member function
    void Talk(std::string text);
    bool IsDead();
};
```

**객체의 생성**
- 변수와 동일하게 스택 또는 힙 메모리에 생성 가능
```cpp
Player khk;
Player hero;

Player *enemy = new Player();
delete enemy;
```
- 계좌 클래스 예시
```cpp
// 클래스 정의
class Account
{
public:
    std::string name;    // 예금주 이름
    double balance;      // 계좌 잔액

    bool Withdraw(double amount);   // 출금
    bool Deposit(double amount);    // 입금
};

int main()
{
    // 객체의 생성 (스택)
    Account kimAccount;
    Account leeAccount;

    // 객체의 생성 (힙)
    Account *parkAccount = new Account();
    delete parkAccount;  // 객체 해제 (소멸)
    
    return 0;
}
```

#### 2-4. 접근 제한자

**클래스 멤버의 접근**
- 멤버 = 멤버 변수 + 멤버 함수
- 멤버 변수/함수에 접근하려면 객체가 필요 (단, static 멤버는 예외)
- 특정 멤버 변수/함수를 클래스 외부에서 접근 불가능하게 만들어 정보 은닉 가능

**값 형식의 객체인 경우 멤버 접근 방법**
- `.` 연산자 사용 (멤버 접근 연산자)

```cpp
Player player1;

player1.name;    // player1이 가진 name 멤버 변수에 접근
player1.Move(2,3);   // player1이 가진 Move() 멤버 함수에 접근
```

**객체의 포인터인 경우**
- 역참조 후 점 연산자 사용 (사용 빈도는 적음)
```cpp
Player *player1 = new Player();

(*player1).name;        // player1 포인터가 가리키는 객체의 name에 접근
(*player1).Move(1,1);     // player1 포인터가 가리키는 객체의 Move()에 접근
```
- 화살표 연산자 (member of pointer 연산자) 사용  
  - 위와 동일한 의미, 단축 표현
```cpp
Player *player1 = new Player();

player1->name;
player1->Move(1,1);
```
**Class Member Access Modifier**
- 정보 은닉을 위해 멤버 접근을 제한할 수 있음
- 클래스 멤버 접근 제한자:
  - `public` → **객체에서 접근 가능**
  - `private` → **클래스 내부의 멤버만 접근 가능**
  - `protected` → 상속받은 클래스의 객체에서만 접근 가능

**왜 클래스 멤버 접근 제한자를 사용하는가?**
- 모든 멤버를 public으로 두면, 멤버에 직접 접근하여 오류를 초래할 수 있음  
  - 예를 들어, 게임에서 플레이어의 체력이 100이 상한선인데 실수로 1000을 할당한다면?

**계좌 클래스 예제**
```cpp
class BankAccount {
private:
    double balance;  // 계좌 잔액 (외부에서 직접 접근 불가)

public:
    // 생성자
    BankAccount(double initialBalance) { balance = initialBalance; }

    // balance 값을 읽는 메서드 (getter)
    double getBalance() { return balance; }

    // balance 값을 변경하는 메서드 (setter)
    void deposit(double amount) {
        if (amount > 0) balance += amount;
    }
};

int main() {
    BankAccount myAccount(1000);

    myAccount.balance = 5000;  // ❌ private 멤버라 직접 접근 불가!
    myAccount.deposit(500);    // ✅ 올바른 접근 방식
    std::cout << myAccount.getBalance();  // 1500 출력

    return 0;
}
```
- 직접 접근을 막고, public 입금 멤버 함수를 통해서만 접근 가능  
- 테스트, 디버깅이 쉬워지고, 오류 가능성이 줄어듦 (방어적 프로그래밍)

#### 2-5. 멤버 변수와 멤버 함수
**멤버 함수의 구현**
- 기존 일반 함수와 유사하게 구현 가능
- **멤버 변수에 직접 접근 가능**하기 때문에 인자로 전달할 데이터가 적음
- 클래스 선언 내에서 구현 가능 (inline 구현)
  ```cpp
  class Account {
  public:
      void SetBalance(double bal) {
          balance = bal;
      }
      double GetBalance() {
          return balance;
      }
  private:
      double balance;
  };
  ```
- 클래스 선언 외부에서 구현 가능 (ClassName::MethodName 사용)
  ```cpp
  class Account {
  public:
      void SetBalance(double bal);
      double GetBalance();
  private:
      double balance;
  };

  void Account::SetBalance(double bal) {
      balance = bal;
  }
  double Account::GetBalance() {
      return balance;
  }
  ```

#### 2-6. 명세와 구현의 분리
- 명세(specification)와 구현의 분리  
  - 클래스의 선언은 .h 파일에 작성  
  - 클래스의 구현은 .cpp 파일에 작성

**헤더 파일**

헤더 파일이 중복 포함되면 컴파일 에러가 발생할 수 있으므로, 이를 방지하기 위해 다음 방법을 사용함.

- ifndef 방식 (전통적인 방법)
  - `#ifndef _ACCOUNT_H_` → _ACCOUNT_H_가 정의되지 않았을 때만 포함  
  - `#define _ACCOUNT_H_` → _ACCOUNT_H_를 정의하여 중복 포함 방지  
  - `#endif` → Include Guard 종료
```cpp
// Account.h
#ifndef _ACCOUNT_H_
#define _ACCOUNT_H_

class Account {
public:
    void SetBalance(double bal);
    double GetBalance();
private:
    double balance;
};

#endif
```
- `#pragma once` 방식 (간결한 방법)
  - 해당 헤더 파일이 한 번만 포함되도록 자동 처리  
  - 별도의 매크로 정의가 필요 없음, 코드가 간결해짐  
  - 단, 일부 오래된 컴파일러에서는 지원되지 않을 수 있음
```cpp
#pragma once

class Account
{
public:
    void SetBalance(double bal);
    double GetBalance();
    
private:
    double balance;
};
```

**구현 파일**
- 대부분의 라이브러리는 클래스 명세(정의)와 구현이 별도의 파일로 분리되어 있음

```cpp
// Account.cpp
#include "Account.h"

void Account::SetBalance(double bal) {
    balance = bal;
}
double Account::GetBalance() {
    return balance;
}
```

**메인 파일**
```cpp
#include <iostream>
#include "Account.h"

int main() {
    // Account.h에 Account 클래스 정의가 있으므로 사용 가능
    Account kimAccount;
    // Account.cpp에 Account::SetBalance() 함수의 본문이 있으므로 링커가 연결됨
    kimAccount.SetBalance(1000.00);     
    double bal = kimAccount.GetBalance();

    std::cout << bal << std::endl;
    return 0;
}
```

#### 2-7. 구조체 vs 클래스
- C++에서는 구조체와 클래스 모두 사용 가능
- 문법적으로는 기본 접근 권한의 차이 외에는 별 차이가 없음  
  - 클래스: 명시되지 않으면 기본값이 private  
  - 구조체: 명시되지 않으면 기본값이 public

**구조체와 클래스 사용 가이드라인**
- 구조체  
  - public 접근이 필요한 데이터를 다룰 때 사용  
  - 멤버 함수를 포함하지 않는 것이 권장됨
- 클래스  
  - private 멤버 변수와 멤버 함수를 사용  
  - 멤버 함수를 통해 멤버 변수에 접근하는 get/set 함수를 구현

---
## 3. 생성자와 소멸자

**생성자**
- 특수한 멤버 함수  
- **객체가 생성될 때 자동으로 호출됨**  
- 초기화 목적으로 사용됨  
- **클래스와 동일한 이름을 가진 멤버 함수**  
- 반환형이 없음  
- 오버로딩 가능

```cpp
class Player {
public:
    // 반환형 없음, 함수 이름이 클래스 이름과 동일함
    Player();
    Player(std::string name);
    Player(std::string name, int health, int xp);
private:
    std::string name;
    int health;
    int xp;
};
```

**소멸자**
- 특수한 멤버 함수  
- **객체가 소멸될 때 자동으로 호출됨**  
- 메모리 및 기타 리소스(파일 close 등) 해제 목적으로 사용됨  
- **클래스 이름 앞에 '~'가 붙은 멤버 함수**  
- 반환형 및 파라미터가 없음  
- 오버로딩 불가능

```cpp
class Player {
public:
    Player();
    Player(std::string name);
    Player(std::string name, int health, int xp);
    ~Player();
private:
    std::string name;
    int health;
    int xp;
};
```

```cpp
{
    Player slayer;
    Player kim {"Kim", 100, 4};
    Player hero {"Hero"};
    Player enemy {"Enemy"};
} // 4개의 객체 소멸 → 4번의 소멸자 호출

Player *enemy = new Player{"Enemy2", 1000, 0};
delete enemy; // 소멸자 호출
```

**기본 생성자**
- 인자가 없는 생성자  
- **클래스에 생성자를 직접 구현하지 않으면, 컴파일러가 기본 생성자를 자동 생성함**  
  - 객체를 인자 없이 생성할 수 있었던 이유는 컴파일러가 기본 생성자를 제공했기 때문
- 인자가 없는 클래스 생성자도 명시적으로 구현해 주는 것이 좋음  
  - 쓰레기 값을 방지하기 위함

```cpp
class Account
{
public:
    Account()
    {
        name = "None";    // 쓰레기 값 방지
        balance = 0.0;
    }

    bool Withdraw(double amount);
    bool Deposit(double amount);

private:
    std::string name;
    double balance;
};
```
**단, 인자가 있는 생성자만 구현한 경우에는 기본 생성자가 자동 생성되지 않음.**

---
## 4. 생성자 오버로딩

- 생성자도 함수이므로 오버로딩이 가능  
- 각각의 생성자는 매개변수가 달라야 함 (함수 오버로딩과 동일)

#### 4-1. 생성자 오버로딩 예시
```cpp
class Player
{
public:
    // 매개변수가 모두 다름
    Player();
    Player(std::string nameVal);
    Player(std::string nameVal, int healthVal, int xpVal);

private:
    std::string name;
    int health;
    int xp;
};
```

```cpp
// 클래스 밖에 생성자를 정의하는 경우
Player::Player()
{
    name = "None";
    health = 0;
    xp = 0;
}

Player::Player(std::string nameVal)
{
    name = nameVal;
    health = 0;
    xp = 0;
}

Player::Player(std::string nameVal, int healthVal, int xpVal)
{
    name = nameVal;
    health = healthVal;
    xp = xpVal;
}
```
오버로딩된 생성자의 활용

```cpp
Player empty;                 // "None", 0, 0

Player hero {"Hero"};         // "Hero", 0, 0

Player kim {"Kim", 100, 5};   // "Kim", 100, 5

Player *player1 = new Player; // "None", 0, 0
delete player1;

Player *player2 = new Player{"Enemy2"};  // "Enemy2", 0, 0
delete player2;

Player *player3 = new Player{"Enemy3", 1000, 0};  // "Enemy3", 1000, 0
delete player3;
```

#### 4-2. 생성자 초기화 리스트
- 기존 생성자는 생성자 본체 내에서 멤버 변수에 값을 대입함  
- 생성자 초기화 리스트를 사용하면 생성과 동시에 값이 지정됨

**기존 초기화 방법**
```cpp
Player::Player() {
  name = "None";
  health = 0;
  xp = 0;
}
```

**생성자 멤버 초기화 리스트 사용**
```cpp
Player::Player()
    : name{"None"}, health{0}, xp{0}
{
}
```

#### 4-3. 생성자 위임
- 여러 생성자 오버로딩에서 유사한 코드가 반복되는 문제 해결  
- 코드 중복 및 오류 가능성을 줄이기 위해, 한 생성자가 다른 생성자를 호출할 수 있음  
  - 생성자 멤버 초기화 리스트에서 다른 생성자를 호출하는 방식으로 가능

**생성자 위임을 사용하지 않는 기존 코드**
```cpp
Player::Player(std::string nameVal, int healthVal, int xpVal)
    : name{nameVal}, health{healthVal}, xp{xpVal}
{
}

Player::Player()
    : name{"None"}, health{0}, xp{0}
{
}

Player::Player(std::string nameVal)
    : name{nameVal}, health{0}, xp{0}
{
}
```

**생성자 위임을 사용한 코드**
```cpp
Player::Player(std::string nameVal, int healthVal, int xpVal)
    : name{nameVal}, health{healthVal}, xp{xpVal}
{
}

Player::Player()
    : Player{"None", 0, 0}    // 호출
{
}

Player::Player(std::string nameVal)
    : Player{nameVal, 0, 0}   // 호출 (주의: 매개변수 이름은 nameVal로 일치시킴)
{
}
```

#### 4-4. 생성자 기본 매개변수
- 생성자도 함수이므로 기본 매개변수 사용 가능

```cpp
class Player
{
public:
    Player(std::string nameVal = "None", int healthVal = 0, int xpVal = 0);

private:
    std::string name;
    int health;
    int xp;
};

Player::Player(std::string nameVal, int healthVal, int xpVal)
    : name{nameVal}, health{healthVal}, xp{xpVal}
{
}
```

```cpp
Player empty;
Player kim{"Kim"};         // "Kim", 0, 0
Player hero{"Hero", 100};   // "Hero", 100, 0
Player enemy{"Enemy", 1000, 0}; // "Enemy", 1000, 0
```

---
### 참고 자료
이 문서 작성에는 [YouTube Playlist: C++ Programming][playlist]를 참고했음.

[playlist]: https://www.youtube.com/playlist?list=PLMcUoebWMS1nzhlx-NbD4KBGEP1UCUDF_

